# frozen_string_literal: true

module ImageGeneration
  class TreeSnippetGenerator < BaseGenerator
    PERSON_BOX_WIDTH = 150
    PERSON_BOX_HEIGHT = 80
    GENERATION_SPACING = 140
    SIBLING_SPACING = 180
    
    def generate(root_person, options = {})
      generations = options[:generations] || 3
      @include_step_relationships = options[:include_step_relationships] != false
      
      start_time = Time.current
      
      begin
        @root_person = root_person
        @generations = generations
        @tree_data = build_tree_structure
        
        create_tree_snippet
        filename = "tree_#{root_person.id}_#{@include_step_relationships ? 'with' : 'without'}_steps_#{SecureRandom.hex(8)}.jpg"
        file_path = save_to_file(filename)
        
        end_time = Time.current
        generation_time_ms = ((end_time - start_time) * 1000).round
        
        # Store in database
        ShareImage.create!(
          person: root_person,
          image_type: 'tree',
          file_path: file_path,
          expires_at: 24.hours.from_now,
          generation_time_ms: generation_time_ms,
          file_size: File.size(Rails.root.join('public', file_path)),
          metadata: { 
            generations: generations, 
            people_count: total_people_count,
            include_step_relationships: @include_step_relationships
          }
        )
        
        file_path
      ensure
        cleanup
      end
    end
    
    private
    
    def create_tree_snippet
      @tree_data = build_tree_structure
    end
    
    def svg_content
      <<~CONTENT
        <!-- Main Background -->
        <rect x="20" y="20" width="#{CANVAS_WIDTH-40}" height="#{CANVAS_HEIGHT-40}" fill="#{COLORS[:card_bg]}" stroke="#{COLORS[:accent]}" stroke-width="3" rx="20"/>
        
        <!-- Tree Header -->
        <rect x="40" y="40" width="#{CANVAS_WIDTH-80}" height="80" fill="#{COLORS[:primary]}" stroke="#{COLORS[:accent]}" stroke-width="2" rx="15"/>
        <text x="#{CANVAS_WIDTH/2}" y="70" text-anchor="middle" font-family="Arial, sans-serif" font-size="28" font-weight="bold" fill="#{COLORS[:text_light]}">
          #{escape_xml(@root_person.full_name)}'s Family Tree
        </text>
        <text x="#{CANVAS_WIDTH/2}" y="100" text-anchor="middle" font-family="Arial, sans-serif" font-size="16" fill="#{COLORS[:text_light]}">
          #{@generations} generations â€¢ #{total_people_count} family members
        </text>
        
        <!-- Tree Structure -->
        #{draw_enhanced_tree_svg}
        
        <!-- Footer -->
        <rect x="40" y="#{CANVAS_HEIGHT-60}" width="#{CANVAS_WIDTH-80}" height="40" fill="#{COLORS[:secondary]}" rx="10"/>
        <text x="#{CANVAS_WIDTH/2}" y="#{CANVAS_HEIGHT-35}" text-anchor="middle" font-family="Arial, sans-serif" font-size="16" font-weight="bold" fill="#{COLORS[:text_light]}">
          ðŸŒ³ Generated by ChronicleTree â€¢ #{Date.current.strftime("%B %Y")}
        </text>
      CONTENT
    end
    
    private
    
    def draw_enhanced_tree_svg
      content = ""
      
      # Calculate tree dimensions and scaling with improved spacing
      tree_bounds = calculate_tree_bounds
      scale_factor = calculate_scale_factor(tree_bounds)
      
      # Apply scaling to positioning with better centering
      center_x = CANVAS_WIDTH / 2
      # Account for header (80px) and footer (70px), with small safety margins
      available_height = CANVAS_HEIGHT - 80 - 70 - 40  # 630 - 80 - 70 - 40 = 440px available
      center_y = 80 + 20 + (available_height / 2)  # 80 + 20 + 220 = 320px center
      
      @tree_data.each do |generation_offset, people|
        next if people.empty?
        
        # Apply dynamic generation spacing based on number of generations
        generation_spacing = calculate_generation_spacing
        y = center_y + (generation_offset * generation_spacing * scale_factor)
        people_count = people.length
        
        # Calculate horizontal spacing to prevent overlap
        # Box width is 220 * scale_factor with minimum 160, so we need more spacing
        min_box_width = [220 * scale_factor, 160].max
        horizontal_spacing = [min_box_width + 40, 200].max  # Box width + 40px minimum gap
        total_width = (people_count - 1) * horizontal_spacing
        start_x = center_x - (total_width / 2)
        
        # Check if generation is too wide for canvas and adjust
        if total_width > (CANVAS_WIDTH - 100)  # Leave 50px margin on each side
          # Reduce spacing but maintain minimum gap
          horizontal_spacing = [(CANVAS_WIDTH - 100) / people_count, min_box_width + 20].max
          total_width = (people_count - 1) * horizontal_spacing
          start_x = center_x - (total_width / 2)
        end
        
        people.each_with_index do |person, index|
          x = start_x + (index * horizontal_spacing)
          is_root = (generation_offset == 0 && person == @root_person)
          content += draw_enhanced_person_box_svg(person, x, y, is_root, scale_factor, generation_offset)
        end
      end
      
      content
    end
    
    def draw_enhanced_person_box_svg(person, x, y, is_root = false, scale_factor = 1.0, generation_offset = 0)
      # Apply scaling to box dimensions with minimum sizes for text readability
      box_width = [220 * scale_factor, 160].max  # Increased minimum width
      box_height = [120 * scale_factor, 90].max  # Increased minimum height
      box_x = x - box_width / 2
      box_y = y - box_height / 2
      
      # Enhanced box styling based on role and generation
      if is_root
        box_color = COLORS[:primary]
        text_color = COLORS[:text_light]
        border_color = COLORS[:accent]
        border_width = 3
      elsif generation_offset < 0  # Ancestors
        box_color = COLORS[:secondary]
        text_color = COLORS[:text_light]
        border_color = COLORS[:accent]
        border_width = 2
      else  # Descendants
        box_color = COLORS[:card_bg]
        text_color = COLORS[:text_primary]
        border_color = COLORS[:primary]
        border_width = 2
      end
      
      # Get relationship to root person with step-relationship support
      relationship_label = get_enhanced_relationship_to_root(person)
      
      # Smart text truncation based on box width
      name = person.full_name
      max_chars = [(box_width / 10).to_i, 12].max  # Dynamic character limit based on box size
      name = "#{name[0..max_chars-4]}..." if name.length > max_chars
      
      birth_year = person.date_of_birth&.year
      death_year = person.date_of_death&.year
      
      # Adjust font size based on box size
      name_font_size = [14 * scale_factor, 11].max.to_i
      label_font_size = [11 * scale_factor, 9].max.to_i
      date_font_size = [12 * scale_factor, 10].max.to_i
      
      <<~BOX
        <!-- Enhanced Person Box for #{person.full_name} (#{box_width.to_i}x#{box_height.to_i}) -->
        <rect x="#{box_x}" y="#{box_y}" width="#{box_width}" height="#{box_height}" 
              fill="#{box_color}" stroke="#{border_color}" stroke-width="#{border_width}" rx="12"/>
        
        <!-- Relationship Label with proper sizing -->
        #{relationship_label ? %{<rect x="#{box_x + 5}" y="#{box_y + 5}" width="#{box_width - 10}" height="20" fill="#{COLORS[:accent]}" rx="4"/>} : ''}
        #{relationship_label ? %{<text x="#{box_x + box_width/2}" y="#{box_y + 18}" text-anchor="middle" font-family="Arial, sans-serif" font-size="#{label_font_size}" font-weight="bold" fill="#{COLORS[:text_light]}">#{escape_xml(relationship_label)}</text>} : ''}
        
        <!-- Person Name with dynamic sizing -->
        <text x="#{box_x + box_width/2}" y="#{box_y + (relationship_label ? 45 : 35)}" text-anchor="middle" font-family="Arial, sans-serif" font-size="#{name_font_size}" font-weight="bold" fill="#{text_color}">
          #{escape_xml(name)}
        </text>
        
        <!-- Life Dates Container with improved layout -->
        #{enhanced_life_dates_svg(box_x, box_y, box_width, birth_year, death_year, relationship_label, text_color, date_font_size)}
      BOX
    end

    def enhanced_life_dates_svg(box_x, box_y, box_width, birth_year, death_year, relationship_label, text_color, date_font_size = 12)
      content = ""
      base_y = box_y + (relationship_label ? 70 : 60)  # More space for relationship label
      
      if birth_year && death_year
        # Both birth and death - show on same line
        dates_text = "#{birth_year} - #{death_year}"
        content += %{<text x="#{box_x + box_width/2}" y="#{base_y}" text-anchor="middle" font-family="Arial, sans-serif" font-size="#{date_font_size}" fill="#{text_color}">#{dates_text}</text>}
      elsif birth_year
        # Only birth year with current age
        age = Date.current.year - birth_year
        content += %{<text x="#{box_x + box_width/2}" y="#{base_y}" text-anchor="middle" font-family="Arial, sans-serif" font-size="#{date_font_size}" fill="#{text_color}">Born #{birth_year}</text>}
        content += %{<text x="#{box_x + box_width/2}" y="#{base_y + 15}" text-anchor="middle" font-family="Arial, sans-serif" font-size="#{[date_font_size - 2, 8].max}" fill="#{text_color}">Age #{age}</text>}
      elsif death_year
        # Only death year (rare case)
        content += %{<text x="#{box_x + box_width/2}" y="#{base_y}" text-anchor="middle" font-family="Arial, sans-serif" font-size="#{date_font_size}" fill="#{text_color}">Died #{death_year}</text>}
      end
      
      content
    end
    
    def get_enhanced_relationship_to_root(person)
      return nil if person == @root_person
      
      # Enhanced multi-generational relationship detection
      # Check for grand-relationships first (grandparents, grandchildren)
      grand_relationship = detect_grand_relationships(person)
      return add_deceased_prefix(grand_relationship, person) if grand_relationship
      
      # Use unified relationship calculator for immediate relationships
      calculator = UnifiedRelationshipCalculator.new(@root_person.user)
      relationship_data = calculator.calculate_relationships_for_person(@root_person)
      
      # Check if this person is in the calculated relationships
      if relationship_data[:relationships][person.id]
        relationship_label = relationship_data[:relationships][person.id][:relationship]
        return add_deceased_prefix(relationship_label, person)
      end
      
      # Fallback to basic relationship detection with step-relationship support
      if @include_step_relationships
        # Check for step-relationships
        step_relationship = detect_step_relationship(person)
        return add_deceased_prefix(step_relationship, person) if step_relationship
      end
      
      # Basic relationship detection
      root_relationships = @root_person.relationships.includes(:relative)
      direct_rel = root_relationships.find { |rel| rel.relative == person }
      if direct_rel
        base_label = case direct_rel.relationship_type
        when 'child' 
          get_child_type(person)
        when 'spouse' 
          get_spouse_type(person, direct_rel.is_ex?)
        when 'sibling' 
          get_sibling_type(person)
        end
        return add_deceased_prefix(base_label, person) if base_label
      end
      
      # Check reverse relationships
      person_relationships = person.relationships.includes(:relative)
      reverse_rel = person_relationships.find { |rel| rel.relative == @root_person }
      if reverse_rel
        base_label = case reverse_rel.relationship_type
        when 'child' 
          get_parent_type(person)
        when 'spouse' 
          get_spouse_type(person, reverse_rel.is_ex?)
        when 'sibling' 
          get_sibling_type(person)
        end
        return add_deceased_prefix(base_label, person) if base_label
      end
      
      'Family'
    end
    
    def draw_tree_svg
      content = ""
      
      # Calculate tree dimensions and scaling
      tree_bounds = calculate_tree_bounds
      scale_factor = calculate_scale_factor(tree_bounds)
      
      # Apply scaling to positioning
      center_x = CANVAS_WIDTH / 2
      # Account for header and footer space
      available_height = CANVAS_HEIGHT - 80 - 70
      center_y = 80 + (available_height / 2)
      
      @tree_data.each do |generation_offset, people|
        next if people.empty?
        
        # Apply dynamic generation spacing based on number of generations
        generation_spacing = calculate_generation_spacing
        y = center_y + (generation_offset * generation_spacing * scale_factor)
        people_count = people.length
        
        # Calculate horizontal spacing with scaling
        horizontal_spacing = [200 * scale_factor, 120].max  # Minimum 120px spacing
        total_width = (people_count - 1) * horizontal_spacing
        start_x = center_x - (total_width / 2)
        
        people.each_with_index do |person, index|
          x = start_x + (index * horizontal_spacing)
          is_root = (generation_offset == 0 && person == @root_person)
          content += draw_person_box_svg(person, x, y, is_root, scale_factor)
        end
      end
      
      content
    end
    
    def draw_person_box_svg(person, x, y, is_root = false, scale_factor = 1.0)
      # Apply scaling to box dimensions
      box_width = [180 * scale_factor, 120].max  # Minimum width
      box_height = [100 * scale_factor, 70].max  # Minimum height
      box_x = x - box_width / 2
      box_y = y - box_height / 2
      
      # Box styling
      box_color = is_root ? COLORS[:primary] : COLORS[:card_bg]
      text_color = is_root ? COLORS[:text_light] : COLORS[:text_primary]
      border_color = is_root ? COLORS[:accent] : COLORS[:text_secondary]
      
      name = person.full_name
      name = "#{name[0..12]}..." if name.length > 15
      
      birth_year = person.date_of_birth&.year
      death_year = person.date_of_death&.year
      
      # Get relationship to root person
      relationship_label = get_relationship_to_root(person)
      
      <<~BOX
        <!-- Person Box for #{person.full_name} -->
        <rect x="#{box_x}" y="#{box_y}" width="#{box_width}" height="#{box_height}" 
              fill="#{box_color}" stroke="#{border_color}" stroke-width="2" rx="10"/>
        
        <!-- Relationship Label -->
        #{relationship_label ? %{<text x="#{box_x + 10}" y="#{box_y + 15}" font-family="Arial, sans-serif" font-size="10" font-weight="bold" fill="#{COLORS[:accent]}">#{escape_xml(relationship_label)}</text>} : ''}
        
        <!-- Person Name -->
        <text x="#{box_x + 10}" y="#{box_y + (relationship_label ? 35 : 25)}" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="#{text_color}">
          #{escape_xml(name)}
        </text>
        
        <!-- Life Dates Container (prevents overlap) -->
        #{life_dates_svg(box_x, box_y, birth_year, death_year, relationship_label, text_color)}
      BOX
    end

    def life_dates_svg(box_x, box_y, birth_year, death_year, relationship_label, text_color)
      content = ""
      base_y = box_y + (relationship_label ? 55 : 45)
      
      if birth_year && death_year
        # Both birth and death - show on same line to prevent overlap
        dates_text = "#{birth_year} - #{death_year}"
        content += %{<text x="#{box_x + 10}" y="#{base_y}" font-family="Arial, sans-serif" font-size="12" fill="#{text_color}">#{dates_text}</text>}
      elsif birth_year
        # Only birth year
        content += %{<text x="#{box_x + 10}" y="#{base_y}" font-family="Arial, sans-serif" font-size="12" fill="#{text_color}">b. #{birth_year}</text>}
      elsif death_year
        # Only death year (rare case)
        content += %{<text x="#{box_x + 10}" y="#{base_y}" font-family="Arial, sans-serif" font-size="12" fill="#{text_color}">d. #{death_year}</text>}
      end
      
      content
    end
    
    def get_relationship_to_root(person)
      return nil if person == @root_person
      
      # Use unified relationship calculator for consistency with main app
      calculator = UnifiedRelationshipCalculator.new(@root_person.user)
      relationship_data = calculator.calculate_relationships_for_person(@root_person)
      
      # Check if this person is in the calculated relationships
      if relationship_data[:relationships][person.id]
        relationship_label = relationship_data[:relationships][person.id][:relationship]
        return add_deceased_prefix(relationship_label, person)
      end
      
      # Fallback to basic relationship detection for edge cases
      root_relationships = @root_person.relationships.includes(:relative)
      
      direct_rel = root_relationships.find { |rel| rel.relative == person }
      if direct_rel
        base_label = case direct_rel.relationship_type
        when 'child' 
          get_child_type(person)
        when 'spouse' 
          direct_rel.is_ex? ? 'Ex-Spouse' : 'Spouse'
        when 'sibling' 
          get_sibling_type(person)
        end
        return add_deceased_prefix(base_label, person) if base_label
      end
      
      person_relationships = person.relationships.includes(:relative)
      reverse_rel = person_relationships.find { |rel| rel.relative == @root_person }
      if reverse_rel
        base_label = case reverse_rel.relationship_type
        when 'child' 
          get_parent_type(person)
        when 'spouse' 
          reverse_rel.is_ex? ? 'Ex-Spouse' : 'Spouse'
        when 'sibling' 
          get_sibling_type(person)
        end
        return add_deceased_prefix(base_label, person) if base_label
      end
      
      'Family'
    end
    
    def get_parent_type(person)
      return 'Parent' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Father' : 'Mother'
    end
    
    def get_child_type(person)
      return 'Child' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Son' : 'Daughter'
    end
    
    def get_sibling_type(person)
      if is_half_sibling_of_root?(person)
        return get_half_sibling_type(person)
      end
      
      return 'Sibling' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Brother' : 'Sister'
    end
    
    def get_spouse_type(person, is_ex = false)
      prefix = is_ex ? 'Ex-' : ''
      return "#{prefix}Spouse" unless person.gender.present?
      
      gender_term = person.gender.downcase == 'male' ? 'Husband' : 'Wife'
      is_ex ? "Ex-#{gender_term}" : gender_term
    end
    
    def is_half_sibling_of_root?(person)
      root_parents = get_parents(@root_person)
      person_parents = get_parents(person)
      shared_parents = root_parents & person_parents
      
      shared_parents.length == 1
    end
    
    def get_half_sibling_type(person)
      return 'Half-Sibling' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Half-Brother' : 'Half-Sister'
    end
    
    def get_grandparent_type(person)
      return 'Grandparent' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Grandfather' : 'Grandmother'
    end

    def get_step_grandparent_type(person)
      return 'Step-Grandparent' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Step-Grandfather' : 'Step-Grandmother'
    end
    
    def is_grandparent_of_root?(person)
      # Check if person is parent of root's parents
      root_parents = @root_person.parents
      return false if root_parents.empty?
      
      root_parents.any? do |parent|
        parent.parents.include?(person)
      end
    end

    def is_step_grandparent_of_root?(person)
      root_parents = @root_person.parents
      return false if root_parents.empty?
      
      root_parents.each do |parent|
        biological_grandparents = parent.parents
        biological_grandparents.each do |grandparent|
          grandparent_spouses = get_spouses(grandparent)
          if grandparent_spouses.include?(person) && !biological_grandparents.include?(person)
            return true
          end
        end
      end
      
      root_parents.each do |parent|
        other_parents = @root_person.parents - [parent]
        other_parents.each do |other_parent|
          other_parent_spouses = get_spouses(other_parent)
          if other_parent_spouses.include?(parent)
            step_parent_parents = get_parents(parent)
            if step_parent_parents.include?(person)
              return true
            end
          end
        end
      end
      
      root_parents.each do |parent|
        parent_spouses = get_spouses(parent)
        parent_spouses.each do |spouse|
          next if root_parents.include?(spouse)
          
          spouse_parents = get_parents(spouse)
          if spouse_parents.include?(person)
            return true
          end
        end
      end
      
      false
    end
    
    def is_grandchild_of_root?(person)
      root_children = @root_person.children
      return false if root_children.empty?
      
      root_children.any? do |child|
        child.children.include?(person)
      end
    end
    
    def is_great_grandparent_of_root?(person)
      root_grandparents = get_parents(@root_person).flat_map { |p| get_parents(p) }
      return false if root_grandparents.empty?
      
      root_grandparents.any? do |grandparent|
        get_parents(grandparent).include?(person)
      end
    end
    
    def is_great_grandchild_of_root?(person)
      root_grandchildren = get_children(@root_person).flat_map { |c| get_children(c) }
      return false if root_grandchildren.empty?
      
      root_grandchildren.any? do |grandchild|
        get_children(grandchild).include?(person)
      end
    end
    
    def is_great_great_grandparent_of_root?(person)
      root_great_grandparents = get_parents(@root_person).flat_map { |p| 
        get_parents(p).flat_map { |gp| get_parents(gp) }
      }
      return false if root_great_grandparents.empty?
      
      root_great_grandparents.any? do |great_grandparent|
        get_parents(great_grandparent).include?(person)
      end
    end
    
    def is_great_great_grandchild_of_root?(person)
      root_great_grandchildren = get_children(@root_person).flat_map { |c| 
        get_children(c).flat_map { |gc| get_children(gc) }
      }
      return false if root_great_grandchildren.empty?
      
      root_great_grandchildren.any? do |great_grandchild|
        get_children(great_grandchild).include?(person)
      end
    end
    
    def get_great_grandparent_type(person)
      return 'Great-Grandparent' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Great-Grandfather' : 'Great-Grandmother'
    end
    
    def get_great_great_grandparent_type(person)
      return 'Great-Great-Grandparent' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Great-Great-Grandfather' : 'Great-Great-Grandmother'
    end
    
    def get_in_law_relationship(person)
      # Check if person is spouse of root's siblings or children
      root_siblings = @root_person.siblings
      root_children = @root_person.children
      
      # Sibling's spouse
      root_siblings.each do |sibling|
        if sibling.current_spouses.include?(person)
          return sibling.gender&.downcase == 'male' ? 'Sister-in-law' : 'Brother-in-law'
        end
      end
      
      # Child's spouse
      root_children.each do |child|
        if child.current_spouses.include?(person)
          return person.gender&.downcase == 'male' ? 'Son-in-law' : 'Daughter-in-law'
        end
      end
      
      # Spouse's family members
      root_spouses = @root_person.current_spouses
      root_spouses.each do |spouse|
        # Spouse's parents
        if spouse.parents.include?(person)
          return person.gender&.downcase == 'male' ? 'Father-in-law' : 'Mother-in-law'
        end
        
        # Spouse's siblings
        if spouse.siblings.include?(person)
          return person.gender&.downcase == 'male' ? 'Brother-in-law' : 'Sister-in-law'
        end
      end
      
      nil
    end
    
    def get_step_child_type(person)
      return 'Step-Child' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Step-Son' : 'Step-Daughter'
    end
    
    def get_step_parent_type(person)
      return 'Step-Parent' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Step-Father' : 'Step-Mother'
    end
    
    def get_step_sibling_type(person)
      return 'Step-Sibling' unless person.gender.present?
      person.gender.downcase == 'male' ? 'Step-Brother' : 'Step-Sister'
    end
    
    def add_deceased_prefix(label, person)
      return label unless person.date_of_death.present?
      return label if label&.start_with?('Late ') # Don't add "Late" if it's already there
      "Late #{label}"
    end
    
    def is_step_child_of_root?(person)
      root_spouses = get_spouses(@root_person)
      return false if root_spouses.empty?
      
      root_spouses.any? do |spouse|
        spouse_children = get_children(spouse)
        spouse_children.include?(person) && !get_children(@root_person).include?(person)
      end
    end
    
    def is_step_parent_of?(child, potential_step_parent)
      child_parents = get_parents(child)
      return false if child_parents.include?(potential_step_parent)
      
      child_parents.any? do |parent|
        parent_spouses = get_spouses(parent)
        parent_spouses.include?(potential_step_parent)
      end
    end
    
    def is_step_sibling_of_root?(person)
      root_parents = get_parents(@root_person)
      person_parents = get_parents(person)
      
      shared_biological_parents = root_parents & person_parents
      return false if shared_biological_parents.any?
      
      root_parents.each do |root_parent|
        root_parent_spouses = get_spouses(root_parent)
        root_parent_spouses.each do |spouse|
          return true if person_parents.include?(spouse)
        end
      end
      
      false
    end
    
    def detect_step_relationship(person)
      root_spouses = get_spouses(@root_person)
      root_spouses.each do |spouse|
        spouse_children = get_children(spouse)
        if spouse_children.include?(person)
          return get_step_child_type(person)
        end
      end
      
      person_spouses = get_spouses(person)
      person_spouses.each do |spouse|
        spouse_children = get_children(spouse)
        if spouse_children.include?(@root_person)
          return get_step_parent_type(person)
        end
      end
      
      nil
    end
    def get_parents(person)
      person.parents.to_a
    end

    def get_children(person)
      person.children.to_a
    end

    def get_spouses(person)
      # Get current spouses (not ex-spouses)
      person.relationships
            .where(relationship_type: 'spouse')
            .where.not(is_ex: true)
            .includes(:relative)
            .map(&:relative)
    end
    
    def add_content_to_vips_image(image)
      begin
        require 'vips'
        
        title_text = "#{@root_person.full_name}'s Family Tree"
        title_display = Vips::Image.text title_text, font: 'sans bold 36'
        image = image.composite title_display, 'over', x: 100, y: 40
        
        stats_text = "#{@generations} generations â€¢ #{total_people_count} family members â€¢ #{get_relationship_summary}"
        stats_display = Vips::Image.text stats_text, font: 'sans 20'
        image = image.composite stats_display, 'over', x: 100, y: 90
        
        image = add_comprehensive_tree_layout(image)
        image = add_detailed_stats_sidebar(image)
        
        footer_text = "Generated by ChronicleTree â€¢ #{Date.current.strftime('%B %Y')} â€¢ Comprehensive Family Visualization"
        footer_display = Vips::Image.text footer_text, font: 'sans 16'
        image = image.composite footer_display, 'over', x: 80, y: CANVAS_HEIGHT - 50
        
        image
      rescue => e
        Rails.logger.error "Comprehensive tree generation failed: #{e.message}"
        super(image)
      end
    end
    
    def add_comprehensive_tree_layout(image)
      y_start = 150
      generation_spacing = 110
      
      # Sort generations for logical display
      sorted_generations = @tree_data.keys.sort
      
      sorted_generations.each do |generation_offset|
        people = @tree_data[generation_offset]
        next if people.empty?
        
        y_position = y_start + (generation_offset * generation_spacing)
        next if y_position < 130 || y_position > CANVAS_HEIGHT - 120
        
        gen_label = get_generation_label(generation_offset)
        if gen_label
          label_display = Vips::Image.text gen_label, font: 'sans bold 18'
          image = image.composite label_display, 'over', x: 50, y: y_position - 20
        end
        
        person_spacing = 280
        if people.length == 1
          x_start = 150
        else
          total_width = (people.length - 1) * person_spacing
          x_start = [150, (800 - total_width) / 2].max
        end
        
        people.each_with_index do |person, index|
          x_position = x_start + (index * person_spacing)
          next if x_position > 750
          
          image = add_detailed_person_info(image, person, x_position, y_position, generation_offset == 0)
        end
      end
      
      image
    end
    
    def add_detailed_person_info(image, person, x, y, is_root = false)
      name = person.full_name
      name = "#{name[0..18]}..." if name.length > 20
      
      font_spec = is_root ? 'sans bold 20' : 'sans bold 16'
      name_display = Vips::Image.text name, font: font_spec
      image = image.composite name_display, 'over', x: x, y: y
      
      info_y = y + 25
      
      if person.date_of_birth
        birth_info = "Born: #{person.date_of_birth.year}"
        birth_display = Vips::Image.text birth_info, font: 'sans 14'
        image = image.composite birth_display, 'over', x: x, y: info_y
        info_y += 20
      end
      
      if person.date_of_death
        death_info = "Died: #{person.date_of_death.year}"
        death_display = Vips::Image.text death_info, font: 'sans 14'
        image = image.composite death_display, 'over', x: x, y: info_y
        info_y += 20
      elsif person.date_of_birth
        age = Date.current.year - person.date_of_birth.year
        age_info = "Age: #{age}"
        age_display = Vips::Image.text age_info, font: 'sans 14'
        image = image.composite age_display, 'over', x: x, y: info_y
        info_y += 20
      end
      
      rel_count = person.relationships.count
      if rel_count > 0
        rel_info = "#{rel_count} connections"
        rel_display = Vips::Image.text rel_info, font: 'sans 12'
        image = image.composite rel_display, 'over', x: x, y: info_y
      end
      
      image
    end
    
    def add_detailed_stats_sidebar(image)
      sidebar_x = 950
      sidebar_y = 160
      
      stats_title = Vips::Image.text "Family Statistics", font: 'sans bold 18'
      image = image.composite stats_title, 'over', x: sidebar_x, y: sidebar_y
      
      stats_y = sidebar_y + 40
      line_spacing = 25
      
      stats_info = get_comprehensive_stats
      stats_info.each do |stat_line|
        stat_display = Vips::Image.text stat_line, font: 'sans 14'
        image = image.composite stat_display, 'over', x: sidebar_x, y: stats_y
        stats_y += line_spacing
      end
      
      image
    end
    
    def get_generation_label(offset)
      case offset
      when -2 then "Great-Grandparents"
      when -1 then "Grandparents & Their Generation"
      when 0 then "Root Person & Spouse(s)"
      when 1 then "Children & Their Generation"
      when 2 then "Grandchildren & Beyond"
      else "Generation #{offset > 0 ? '+' : ''}#{offset}"
      end
    end
    
    def get_relationship_summary
      all_people = @tree_data.values.flatten.uniq
      total_relationships = all_people.map { |p| p.relationships.count }.sum
      "#{total_relationships} relationships"
    end
    
    def get_comprehensive_stats
      all_people = @tree_data.values.flatten.uniq
      
      stats = []
      stats << "Total People: #{all_people.count}"
      stats << "Generations: #{@tree_data.keys.length}"
      
      # Living vs deceased
      living = all_people.count { |p| p.date_of_death.nil? }
      deceased = all_people.count - living
      stats << "Living: #{living}"
      stats << "Deceased: #{deceased}" if deceased > 0
      
      # Age statistics for living people
      living_with_birth = all_people.select { |p| p.date_of_death.nil? && p.date_of_birth }
      if living_with_birth.any?
        ages = living_with_birth.map { |p| Date.current.year - p.date_of_birth.year }
        stats << "Age Range: #{ages.min}-#{ages.max}"
        stats << "Average Age: #{ages.sum / ages.length}"
      end
      
      # Family connections
      total_relationships = all_people.map { |p| p.relationships.count }.sum
      stats << "Total Connections: #{total_relationships}"
      
      # Gender distribution (if available)
      male_count = all_people.count { |p| p.gender&.downcase == 'male' }
      female_count = all_people.count { |p| p.gender&.downcase == 'female' }
      if male_count > 0 || female_count > 0
        stats << "Male: #{male_count}"
        stats << "Female: #{female_count}"
      end
      
      stats
    end
    
    def add_tree_header(image)
      # Add attractive header with title and stats
      header_height = 120
      
      # Create header background with gradient
      header_bg = Vips::Image.new_from_array [[34, 197, 94]] # Green theme for trees
      header_bg = header_bg.embed 0, 0, CANVAS_WIDTH, header_height, extend: :copy
      image = image.composite header_bg, 'over', x: 0, y: 0
      
      # Add main title
      title_text = "ðŸŒ³ #{@root_person.full_name}'s Family Tree"
      white_title = create_white_text(title_text, 'sans bold 32')
      image = image.composite white_title, 'over', x: 80, y: 30
      
      # Add subtitle with stats
      subtitle = "#{@generations} generations â€¢ #{total_people_count} family members â€¢ #{relationship_count} connections"
      white_subtitle = create_white_text(subtitle, 'sans 18')
      image = image.composite white_subtitle, 'over', x: 80, y: 75
      
      image
    end
    
    def add_enhanced_tree_structure(image)
      # Create a more visually appealing tree structure
      y_start = 160
      generation_spacing = 140
      person_box_width = 180
      person_box_height = 90
      
      Rails.logger.info "Building enhanced tree structure"
      
      # Sort generations for display
      sorted_generations = @tree_data.keys.sort
      
      sorted_generations.each do |generation_offset|
        people = @tree_data[generation_offset]
        next if people.empty?
        
        y_position = y_start + (generation_offset * generation_spacing)
        next if y_position < 120 || y_position > CANVAS_HEIGHT - 150
        
        # Calculate layout for this generation
        people_spacing = 220
        if people.length == 1
          x_start = CANVAS_WIDTH / 2 - person_box_width / 2
        else
          total_width = (people.length - 1) * people_spacing
          x_start = (CANVAS_WIDTH - total_width - person_box_width) / 2
        end
        
        people.each_with_index do |person, index|
          x_position = x_start + (index * people_spacing)
          next if x_position < 20 || x_position > CANVAS_WIDTH - person_box_width - 20
          
          # Add person card
          image = add_person_card(image, person, x_position, y_position, generation_offset == 0)
        end
        
        # Add generation label
        gen_label = generation_label(generation_offset)
        if gen_label
          label_text = create_colored_text(gen_label, 'sans bold 14', [107, 114, 128])
          image = image.composite label_text, 'over', x: 20, y: y_position + 30
        end
      end
      
      image
    end
    
    def add_person_card(image, person, x, y, is_root = false)
      # Create attractive person cards with different colors
      card_width = 180
      card_height = 90
      
      # Choose colors based on role
      if is_root
        bg_color = [59, 130, 246]  # Blue for root person
        text_color = [255, 255, 255]  # White text
      else
        bg_color = [255, 255, 255]  # White for others
        text_color = [75, 85, 99]   # Dark gray text
      end
      
      # Create card background
      card_bg = Vips::Image.new_from_array [bg_color]
      card_bg = card_bg.embed 0, 0, card_width, card_height, extend: :copy
      image = image.composite card_bg, 'over', x: x, y: y
      
      # Add card border
      if is_root
        border_color = [34, 197, 94]  # Green border for root
      else
        border_color = [229, 231, 235]  # Light gray border
      end
      
      # Add person's name
      name = person.full_name
      name = "#{name[0..15]}..." if name.length > 18
      
      if is_root
        name_text = create_white_text(name, 'sans bold 16')
      else
        name_text = create_colored_text(name, 'sans bold 16', text_color)
      end
      image = image.composite name_text, 'over', x: x + 10, y: y + 15
      
      # Add birth year
      if person.date_of_birth
        birth_text = "Born #{person.date_of_birth.year}"
        if is_root
          birth_display = create_white_text(birth_text, 'sans 12')
        else
          birth_display = create_colored_text(birth_text, 'sans 12', text_color)
        end
        image = image.composite birth_display, 'over', x: x + 10, y: y + 40
      end
      
      # Add death year if applicable
      if person.date_of_death
        death_text = "Died #{person.date_of_death.year}"
        if is_root
          death_display = create_white_text(death_text, 'sans 12')
        else
          death_display = create_colored_text(death_text, 'sans 12', text_color)
        end
        image = image.composite death_display, 'over', x: x + 10, y: y + 60
      elsif person.date_of_birth
        age = Date.current.year - person.date_of_birth.year
        age_text = "Age #{age}"
        if is_root
          age_display = create_white_text(age_text, 'sans 12')
        else
          age_display = create_colored_text(age_text, 'sans 12', text_color)
        end
        image = image.composite age_display, 'over', x: x + 10, y: y + 60
      end
      
      image
    end
    
    def add_family_stats_panel(image)
      # Add a stats panel on the right side
      panel_width = 200
      panel_x = CANVAS_WIDTH - panel_width - 20
      panel_y = 160
      
      # Create panel background
      panel_bg = Vips::Image.new_from_array [[249, 250, 251]]
      panel_bg = panel_bg.embed 0, 0, panel_width, 300, extend: :copy
      image = image.composite panel_bg, 'over', x: panel_x, y: panel_y
      
      # Add panel title
      stats_title = create_colored_text('ðŸ“Š Family Statistics', 'sans bold 16', [59, 130, 246])
      image = image.composite stats_title, 'over', x: panel_x + 10, y: panel_y + 20
      
      # Add various stats
      stats_y = panel_y + 60
      line_spacing = 25
      
      # Total people
      total_text = create_colored_text("ðŸ‘¥ #{total_people_count} family members", 'sans 14', [75, 85, 99])
      image = image.composite total_text, 'over', x: panel_x + 10, y: stats_y
      stats_y += line_spacing
      
      # Generations
      gen_text = create_colored_text("ðŸ”„ #{@generations} generations", 'sans 14', [75, 85, 99])
      image = image.composite gen_text, 'over', x: panel_x + 10, y: stats_y
      stats_y += line_spacing
      
      # Living members
      living_count = count_living_members
      living_text = create_colored_text("ðŸ’š #{living_count} living", 'sans 14', [34, 197, 94])
      image = image.composite living_text, 'over', x: panel_x + 10, y: stats_y
      stats_y += line_spacing
      
      # Age range
      age_range = calculate_age_range
      if age_range
        age_text = create_colored_text("ðŸ“… Ages #{age_range}", 'sans 14', [75, 85, 99])
        image = image.composite age_text, 'over', x: panel_x + 10, y: stats_y
      end
      
      image
    end
    
    def add_tree_footer(image)
      # Add attractive footer
      footer_y = CANVAS_HEIGHT - 40
      
      footer_text = "ðŸŒ³ Generated by ChronicleTree â€¢ #{Date.current.strftime('%B %Y')} â€¢ Family Tree Visualization"
      footer_styled = create_colored_text(footer_text, 'sans 14', [107, 114, 128])
      image = image.composite footer_styled, 'over', x: 80, y: footer_y
      
      image
    end
    
    def generation_label(offset)
      case offset
      when -2 then "Great-Grandparents"
      when -1 then "Grandparents"
      when 0 then "Root Person"
      when 1 then "Children"
      when 2 then "Grandchildren"
      else nil
      end
    end
    
    def relationship_count
      @tree_data.values.flatten.map { |p| p.relationships.count }.sum
    end
    
    def count_living_members
      @tree_data.values.flatten.count { |p| p.date_of_death.nil? }
    end
    
    def calculate_age_range
      living_people = @tree_data.values.flatten.select { |p| p.date_of_death.nil? && p.date_of_birth }
      return nil if living_people.empty?
      
      ages = living_people.map { |p| Date.current.year - p.date_of_birth.year }
      "#{ages.min}-#{ages.max}"
    end
    
    def create_white_text(text, font)
      # Simplified white text creation
      begin
        Vips::Image.text text, font: font
      rescue => e
        Rails.logger.warn "White text creation failed: #{e.message}"
        Vips::Image.text text, font: 'sans 14'
      end
    end
    
    def create_colored_text(text, font, color_rgb)
      # Simplified colored text creation
      begin
        Vips::Image.text text, font: font
      rescue => e
        Rails.logger.warn "Colored text creation failed: #{e.message}"
        Vips::Image.text text, font: 'sans 14'
      end
    end
    
    def add_tree_structure_to_vips(image)
      # Add a simplified tree structure representation with better positioning
      y_start = 200  # Start lower to avoid title overlap
      generation_spacing = 120  # More space between generations
      person_spacing = 200  # More space between people
      
      Rails.logger.info "Adding tree structure: #{@tree_data.keys.length} generations"
      
      # Sort generations for consistent display (grandparents, parents, root, children, grandchildren)
      sorted_generations = @tree_data.keys.sort
      
      sorted_generations.each do |generation_offset|
        people = @tree_data[generation_offset]
        next if people.empty?
        
        y_position = y_start + (generation_offset * generation_spacing)
        
        # Skip if position is outside visible area
        next if y_position < 150 || y_position > CANVAS_HEIGHT - 100
        
        Rails.logger.info "Generation #{generation_offset}: #{people.length} people at y=#{y_position}"
        
        # Calculate horizontal positioning - center the generation
        if people.length == 1
          x_start = CANVAS_WIDTH / 2 - 75  # Center single person
        else
          total_width = (people.length - 1) * person_spacing
          x_start = (CANVAS_WIDTH - total_width) / 2
        end
        
        people.each_with_index do |person, person_index|
          x_position = x_start + (person_index * person_spacing)
          
          # Skip if position is outside visible area
          next if x_position < 50 || x_position > CANVAS_WIDTH - 200
          
          begin
            # Person name
            is_root = (generation_offset == 0 && person == @root_person)
            font_spec = is_root ? 'sans bold 14' : 'sans 14'
            
            name = person.full_name
            name = "#{name[0..12]}..." if name.length > 15
            
            person_text = Vips::Image.text name, font: font_spec
            image = image.composite person_text, 'over', x: x_position, y: y_position
            
            # Birth year
            if person.date_of_birth
              birth_text = Vips::Image.text "b. #{person.date_of_birth.year}", font: 'sans 12'
              image = image.composite birth_text, 'over', x: x_position, y: y_position + 25
            end
            
            # Death year if applicable
            if person.date_of_death
              death_text = Vips::Image.text "d. #{person.date_of_death.year}", font: 'sans 12'
              image = image.composite death_text, 'over', x: x_position, y: y_position + 45
            end
            
            Rails.logger.info "Added person #{person.full_name} at (#{x_position}, #{y_position})"
          rescue => e
            Rails.logger.warn "Failed to add person #{person.full_name}: #{e.message}"
          end
        end
      end
      
      image
    end
    
    def escape_xml(text)
      text.to_s.gsub('&', '&amp;').gsub('<', '&lt;').gsub('>', '&gt;').gsub('"', '&quot;').gsub("'", '&apos;')
    end
    
    def build_tree_structure
      # Use unified relationship calculator to get consistent family network
      calculator = UnifiedRelationshipCalculator.new(@root_person.user)
      all_people = @root_person.user.people.to_a
      
      # Build connected family network similar to familyTreeHierarchicalLayout.js
      connected_family = collect_connected_family(all_people)
      
      # Build generations using proper generation logic
      structure = {}
      
      case @generations
      when 1
        # Only root person (generation 0)
        structure[0] = find_people_in_generation(0, connected_family)
      when 2
        # Root + one level (either parents OR children, prefer children)
        structure[0] = find_people_in_generation(0, connected_family)
        children = find_people_in_generation(1, connected_family)
        if children.any?
          structure[1] = children
        else
          # If no children, show parents instead
          parents = find_people_in_generation(-1, connected_family)
          structure[-1] = parents if parents.any?
        end
      when 3
        # Root + parents + children (classic 3-generation view)
        structure[-1] = find_people_in_generation(-1, connected_family)
        structure[0] = find_people_in_generation(0, connected_family)
        structure[1] = find_people_in_generation(1, connected_family)
      when 4
        # Root + 1 level up and 2 levels down (prefer showing descendants)
        structure[-1] = find_people_in_generation(-1, connected_family)
        structure[0] = find_people_in_generation(0, connected_family)
        structure[1] = find_people_in_generation(1, connected_family)
        structure[2] = find_people_in_generation(2, connected_family)
      when 5
        # Root + 2 levels up and 2 levels down
        structure[-2] = find_people_in_generation(-2, connected_family)
        structure[-1] = find_people_in_generation(-1, connected_family)
        structure[0] = find_people_in_generation(0, connected_family)
        structure[1] = find_people_in_generation(1, connected_family)
        structure[2] = find_people_in_generation(2, connected_family)
      else
        # Default to 3 generations for any other value
        structure[-1] = find_people_in_generation(-1, connected_family)
        structure[0] = find_people_in_generation(0, connected_family)
        structure[1] = find_people_in_generation(1, connected_family)
      end
      
      # Remove empty generations
      structure.reject { |gen, people| people.empty? }
    end
    
    def collect_connected_family(all_people)
      # Enhanced version that properly includes multi-generational family and step-relatives
      calculator = UnifiedRelationshipCalculator.new(@root_person.user)
      root_relationships = calculator.calculate_relationships_for_person(@root_person)
      
      connected_people = [@root_person]
      
      # Add all people who have relationships with the root person from calculator
      root_relationships[:relationships].each do |person_id, rel_info|
        connected_people << rel_info[:person]
      end
      
      # Add immediate biological family members
      connected_people += @root_person.parents.to_a
      connected_people += @root_person.current_spouses.to_a
      connected_people += @root_person.ex_spouses.to_a  
      connected_people += @root_person.deceased_spouses.to_a
      connected_people += @root_person.children.to_a
      connected_people += @root_person.siblings.to_a
      
      # Add multi-generational family members
      # Add grandparents (parents of parents)
      @root_person.parents.each do |parent|
        connected_people += parent.parents.to_a
      end
      
      # Add grandchildren (children of children)
      @root_person.children.each do |child|
        connected_people += child.children.to_a
      end
      
      # Add great-grandparents if needed for 5 generations
      if @generations >= 5
        @root_person.parents.each do |parent|
          parent.parents.each do |grandparent|
            connected_people += grandparent.parents.to_a
          end
        end
      end
      
      # Add great-grandchildren if needed for 5 generations
      if @generations >= 5
        @root_person.children.each do |child|
          child.children.each do |grandchild|
            connected_people += grandchild.children.to_a
          end
        end
      end
      
      # Add step-relationships if requested
      if @include_step_relationships
        # Add step-parents
        @root_person.parents.each do |parent|
          parent_spouses = get_spouses(parent)
          parent_spouses.each do |spouse|
            unless @root_person.parents.include?(spouse)
              connected_people << spouse  # step-parent
            end
          end
        end
        
        # Add step-children
        @root_person.current_spouses.each do |spouse|
          spouse_children = get_children(spouse)
          spouse_children.each do |child|
            unless @root_person.children.include?(child)
              connected_people << child  # step-child
            end
          end
        end
        
        # Add step-siblings
        @root_person.parents.each do |parent|
          parent_spouses = get_spouses(parent)
          parent_spouses.each do |step_parent|
            next if @root_person.parents.include?(step_parent)
            
            step_parent_children = get_children(step_parent)
            step_parent_children.each do |step_sibling|
              next if step_sibling == @root_person
              next if @root_person.siblings.include?(step_sibling)
              
              connected_people << step_sibling
            end
          end
        end
        
        # Add step-grandparents
        @root_person.parents.each do |parent|
          parent.parents.each do |grandparent|
            grandparent_spouses = get_spouses(grandparent)
            grandparent_spouses.each do |step_grandparent|
              unless parent.parents.include?(step_grandparent)
                connected_people << step_grandparent
              end
            end
          end
        end
        
        # Add step-grandchildren (children of step-children)
        @root_person.current_spouses.each do |spouse|
          spouse_children = get_children(spouse)
          spouse_children.each do |step_child|
            unless @root_person.children.include?(step_child)
              # This is a step-child, add their children (step-grandchildren)
              step_child.children.each do |step_grandchild|
                connected_people << step_grandchild
              end
            end
          end
        end
      end
      
      connected_people.uniq.select { |person| all_people.include?(person) }
    end
    
    def find_people_in_generation(generation_offset, connected_people)
      case generation_offset
      when 0
        # Include root person and all their spouses (current, ex, and deceased)
        root_gen = [@root_person]
        current_spouses = @root_person.current_spouses.select { |s| connected_people.include?(s) }
        ex_spouses = @root_person.ex_spouses.select { |s| connected_people.include?(s) }
        deceased_spouses = @root_person.deceased_spouses.select { |s| connected_people.include?(s) }
        root_gen += current_spouses + ex_spouses + deceased_spouses
        root_gen.uniq
      when -1
        parents = @root_person.parents.select { |p| connected_people.include?(p) }
        if @include_step_relationships
          step_parents = get_parents_with_step_relationships(@root_person).select { |p| connected_people.include?(p) && !parents.include?(p) }
          (parents + step_parents).uniq
        else
          parents
        end
      when -2
        grandparents = []
        if @include_step_relationships
          (@root_person.parents + get_parents_with_step_relationships(@root_person)).uniq.each do |parent|
            grandparents += (parent.parents + get_parents_with_step_relationships(parent)).select { |gp| connected_people.include?(gp) }
          end
        else
          @root_person.parents.each do |parent|
            grandparents += parent.parents.select { |gp| connected_people.include?(gp) }
          end
        end
        grandparents.uniq
      when 1
        children = @root_person.children.select { |c| connected_people.include?(c) }
        if @include_step_relationships
          step_children = get_children_with_step_relationships(@root_person).select { |c| connected_people.include?(c) && !children.include?(c) }
          (children + step_children).uniq
        else
          children
        end
      when 2
        grandchildren = []
        if @include_step_relationships
          (@root_person.children + get_children_with_step_relationships(@root_person)).uniq.each do |child|
            grandchildren += (child.children + get_children_with_step_relationships(child)).select { |gc| connected_people.include?(gc) }
          end
        else
          @root_person.children.each do |child|
            grandchildren += child.children.select { |gc| connected_people.include?(gc) }
          end
        end
        grandchildren.uniq
      else
        []
      end
    end
    
    def detect_grand_relationships(person)
      # Check if person is a grandparent (parent of root's parents)
      @root_person.parents.each do |parent|
        if parent.parents.include?(person)
          return person.gender&.downcase == 'male' ? 'Grandfather' : 'Grandmother'
        end
      end
      
      # Check if person is a grandchild (child of root's children)
      @root_person.children.each do |child|
        if child.children.include?(person)
          return person.gender&.downcase == 'male' ? 'Grandson' : 'Granddaughter'
        end
      end
      
      # Check if person is a great-grandparent (parent of grandparents)
      @root_person.parents.each do |parent|
        parent.parents.each do |grandparent|
          if grandparent.parents.include?(person)
            return person.gender&.downcase == 'male' ? 'Great-Grandfather' : 'Great-Grandmother'
          end
        end
      end
      
      # Check if person is a great-grandchild (child of grandchildren)
      @root_person.children.each do |child|
        child.children.each do |grandchild|
          if grandchild.children.include?(person)
            return person.gender&.downcase == 'male' ? 'Great-Grandson' : 'Great-Granddaughter'
          end
        end
      end
      
      # Check for step-grand relationships if enabled
      if @include_step_relationships
        # Step-grandparents (spouses of grandparents)
        @root_person.parents.each do |parent|
          parent.parents.each do |grandparent|
            grandparent_spouses = get_spouses(grandparent)
            grandparent_spouses.each do |step_grandparent|
              if step_grandparent == person && !parent.parents.include?(person)
                return person.gender&.downcase == 'male' ? 'Step-Grandfather' : 'Step-Grandmother'
              end
            end
          end
        end
        
        # Step-grandchildren (children of step-children)
        step_children = []
        @root_person.current_spouses.each do |spouse|
          spouse_children = get_children(spouse)
          spouse_children.each do |child|
            unless @root_person.children.include?(child)
              step_children << child
            end
          end
        end
        
        step_children.each do |step_child|
          if step_child.children.include?(person)
            return person.gender&.downcase == 'male' ? 'Step-Grandson' : 'Step-Granddaughter'
          end
        end
      end
      
      nil
    end
    
    def get_parents(person)
      # Get direct biological parents only (step relationships detected logically)
      person.related_by_relationships
            .where(relationship_type: 'child')
            .includes(:person)
            .map(&:person)
    end
    
    def get_children(person)
      # Get direct biological children only (step relationships detected logically)
      person.relationships
            .where(relationship_type: 'child')
            .includes(:relative)
            .map(&:relative)
    end
    
    def get_parents_with_step_relationships(person)
      # Get both biological and step parents
      biological_parents = get_parents(person)
      step_parents = []
      
      # Find step-parents (spouses of biological parents who are not biological parents)
      biological_parents.each do |parent|
        parent_spouses = get_spouses(parent)
        parent_spouses.each do |spouse|
          unless biological_parents.include?(spouse)
            step_parents << spouse
          end
        end
      end
      
      (biological_parents + step_parents).uniq
    end
    
    def get_children_with_step_relationships(person)
      # Get both biological children and step-children
      biological_children = get_children(person)
      step_children = []
      
      # Find step-children (children of spouses who are not biological children)
      spouses = get_spouses(person)
      spouses.each do |spouse|
        spouse_children = get_children(spouse)
        spouse_children.each do |child|
          unless biological_children.include?(child)
            step_children << child
          end
        end
      end
      
      (biological_children + step_children).uniq
    end
    
    def get_spouses(person)
      # Get all spouses including ex-spouses and deceased
      all_spouses = person.relationships
                          .where(relationship_type: 'spouse')
                          .includes(:relative)
                          .map(&:relative)
      
      # Also check reverse relationships
      reverse_spouses = person.related_by_relationships
                              .where(relationship_type: 'spouse')
                              .includes(:person)
                              .map(&:person)
      
      (all_spouses + reverse_spouses).uniq
    end
    
    def draw_tree_structure
      center_x = CANVAS_WIDTH / 2
      # Account for header and footer space
      available_height = CANVAS_HEIGHT - 80 - 70
      center_y = 80 + (available_height / 2)
      
      @tree_data.each do |generation_offset, people|
        next if people.empty?
        
        generation_spacing = calculate_generation_spacing
        y = center_y + (generation_offset * generation_spacing)
        people_count = people.length
        
        # Calculate starting X position to center the generation
        total_width = (people_count - 1) * SIBLING_SPACING
        start_x = center_x - (total_width / 2)
        
        people.each_with_index do |person, index|
          x = start_x + (index * SIBLING_SPACING)
          is_root = (generation_offset == 0)
          draw_person_box(person, x, y, is_root)
        end
      end
      
      # Draw connection lines
      draw_connection_lines
    end
    
    def draw_person_box(person, x, y, is_root = false)
      box_x = x - PERSON_BOX_WIDTH / 2
      box_y = y - PERSON_BOX_HEIGHT / 2
      
      # Box styling
      box_color = is_root ? COLORS[:primary] : COLORS[:card_bg]
      text_color = is_root ? COLORS[:text_light] : COLORS[:text_primary]
      border_color = is_root ? COLORS[:accent] : COLORS[:text_secondary]
      
      # Draw box
      add_rounded_rectangle(
        box_x, 
        box_y, 
        PERSON_BOX_WIDTH, 
        PERSON_BOX_HEIGHT,
        {
          radius: 10,
          color: box_color,
          border_color: border_color,
          border_width: 2
        }
      )
      
      # Person's name (truncated if needed)
      name = person.full_name
      name = "#{name[0..12]}..." if name.length > 15
      
      add_text(name, box_x + 10, box_y + 15, {
        size: 14,
        weight: 'bold',
        color: text_color,
        max_width: 18
      })
      
      # Birth year
      birth_year = person.date_of_birth&.year || person.birth_year
      if birth_year
        add_text("b. #{birth_year}", box_x + 10, box_y + 35, {
          size: 12,
          color: text_color
        })
      end
      
      # Death year (if applicable)
      death_year = person.date_of_death&.year || person.death_year
      if death_year
        add_text("d. #{death_year}", box_x + 10, box_y + 50, {
          size: 12,
          color: text_color
        })
      end
    end
    
    def draw_connection_lines
      center_x = CANVAS_WIDTH / 2
      # Account for header and footer space
      available_height = CANVAS_HEIGHT - 80 - 70
      center_y = 80 + (available_height / 2)
      
      # Draw parent-child connections
      @tree_data.each do |generation_offset, people|
        next if generation_offset >= 0 || people.empty?
        
        children_generation = @tree_data[generation_offset + 1] || []
        next if children_generation.empty?
        
        people.each do |parent|
          parent_x = calculate_person_x(parent, generation_offset)
          generation_spacing = calculate_generation_spacing
          parent_y = center_y + (generation_offset * generation_spacing) + PERSON_BOX_HEIGHT / 2
          
          # Find this parent's children in the next generation
          parent_children = get_children(parent) & children_generation
          
          parent_children.each do |child|
            child_x = calculate_person_x(child, generation_offset + 1)
            generation_spacing = calculate_generation_spacing
            child_y = center_y + ((generation_offset + 1) * generation_spacing) - PERSON_BOX_HEIGHT / 2
            
            draw_connection_line(parent_x, parent_y, child_x, child_y)
          end
        end
      end
    end
    
    def calculate_person_x(person, generation_offset)
      people_in_generation = @tree_data[generation_offset] || []
      person_index = people_in_generation.index(person) || 0
      people_count = people_in_generation.length
      
      center_x = CANVAS_WIDTH / 2
      total_width = (people_count - 1) * SIBLING_SPACING
      start_x = center_x - (total_width / 2)
      
      start_x + (person_index * SIBLING_SPACING)
    end
    
    def draw_connection_line(x1, y1, x2, y2)
      # Create a simple line using ImageMagick drawing
      @canvas = @canvas.combine_options do |c|
        c.stroke COLORS[:text_secondary]
        c.strokewidth 2
        c.fill "none"
        
        # Draw T-shaped connection for better hierarchy visualization
        mid_y = y1 + (y2 - y1) / 2
        
        # Vertical line from parent
        c.draw "line #{x1},#{y1} #{x1},#{mid_y}"
        # Horizontal line
        c.draw "line #{[x1, x2].min},#{mid_y} #{[x1, x2].max},#{mid_y}"
        # Vertical line to child
        c.draw "line #{x2},#{mid_y} #{x2},#{y2}"
      end
    end
    
    def add_title
      title_text = "#{@root_person.full_name}'s Family Tree"
      add_text(title_text, CANVAS_WIDTH / 2 - 300, 40, {
        size: 28,
        weight: 'bold',
        color: COLORS[:text_light],
        max_width: 40
      })
      
      # Subtitle with generation info
      subtitle = "#{@generations} generations â€¢ #{total_people_count} family members"
      add_text(subtitle, CANVAS_WIDTH / 2 - 200, 75, {
        size: 16,
        color: COLORS[:text_light]
      })
    end
    
    def add_footer
      footer_y = CANVAS_HEIGHT - 40
      
      # App branding
      add_text("Generated by ChronicleTree", 80, footer_y, {
        size: 14,
        color: COLORS[:text_light]
      })
      
      # Date generated
      date_text = Date.current.strftime("%B %Y")
      add_text(date_text, CANVAS_WIDTH - 180, footer_y, {
        size: 14,
        color: COLORS[:text_light]
      })
    end
    
    def calculate_tree_bounds
      return { width: 0, height: 0 } if @tree_data.empty?
      
      max_people_in_generation = @tree_data.values.map(&:length).max
      generations_count = @tree_data.keys.length
      
      # Calculate estimated tree dimensions
      estimated_width = max_people_in_generation * 200  # Original horizontal spacing
      estimated_height = generations_count * 120  # Original vertical spacing
      
      { width: estimated_width, height: estimated_height }
    end
    
    def calculate_generation_spacing
      # Dynamic spacing based on number of generations to prevent overlap
      generations_count = @tree_data.keys.length
      case generations_count
      when 1, 2
        120  # Standard spacing for small trees
      when 3
        100  # Slightly reduced for 3 generations
      when 4
        85   # More compact for 4 generations
      when 5
        70   # Very compact for 5 generations
      else
        # For 6+ generations, calculate to fit available space
        available_height = CANVAS_HEIGHT - 80 - 70 - 40  # Account for header, footer, margins
        spacing = available_height / generations_count
        [spacing, 55].max.to_i  # Minimum 55px spacing
      end
    end
    
    def calculate_scale_factor(tree_bounds)
      return 1.0 if tree_bounds[:width] == 0 || tree_bounds[:height] == 0
      
      # Available space (leaving margins for title and footer)
      available_width = CANVAS_WIDTH - 120  # 60px margin on each side
      available_height = CANVAS_HEIGHT - 200  # Space for title (130px) and footer (70px)
      
      # Calculate scale factors for width and height
      width_scale = available_width.to_f / tree_bounds[:width]
      height_scale = available_height.to_f / tree_bounds[:height]
      
      # Use the smaller scale factor to ensure everything fits
      scale_factor = [width_scale, height_scale, 1.0].min  # Never scale up, only down
      
      # Ensure minimum readability
      [scale_factor, 0.4].max  # Minimum 40% scale
    end
    
    def total_people_count
      @tree_data.values.flatten.uniq.count
    end
  end
end